{"version":3,"file":"qr-scanner.umd.min.js","sources":["src/qr-scanner.js"],"sourcesContent":["export default class QrScanner {\n    /* async */\n    static hasCamera() {\n        return QrScanner.listCameras(false)\n            .then(cameras => !!cameras.length)\n            .catch(() => false);\n    }\n\n    /* async */\n    static listCameras(requestLabels = false) {\n        if (!navigator.mediaDevices) return Promise.resolve([]);\n\n        // Note that enumerateDevices can always be called and does not prompt the user for permission.\n        // However, enumerateDevices only includes device labels if served via https and an active media stream exists\n        // or permission to access the camera was given. Therefore, ask for camera permission by opening a stream, if\n        // labels were requested.\n        let openedStream = null;\n        return (requestLabels\n            ? navigator.mediaDevices.getUserMedia({ audio: false, video: true })\n                .then(stream => openedStream = stream)\n                // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in\n                // use and some browsers disallow a second stream.\n                .catch(() => {})\n            : Promise.resolve()\n        )\n            .then(() => navigator.mediaDevices.enumerateDevices())\n            .then(devices => devices.filter(device => device.kind === 'videoinput').map((device, i) => ({\n                id: device.deviceId,\n                label: device.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`),\n            })))\n            .finally(() => {\n                // close the stream we just opened for getting camera access for listing the device labels\n                if (!openedStream) return;\n                for (const track of openedStream.getTracks()) {\n                    track.stop();\n                    openedStream.removeTrack(track);\n                }\n            });\n    }\n\n    constructor(\n        video,\n        onDecode,\n        canvasSizeOrOnDecodeError = this._onDecodeError,\n        canvasSizeOrCalculateScanRegion = this._calculateScanRegion,\n        preferredCamera = 'environment'\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n        this._onDecode = onDecode;\n        this._legacyCanvasSize = QrScanner.DEFAULT_CANVAS_SIZE;\n        this._preferredCamera = preferredCamera;\n        this._active = false;\n        this._paused = false;\n        this._flashOn = false;\n\n        if (typeof canvasSizeOrOnDecodeError === 'number') {\n            // legacy function signature where the third argument is the canvas size\n            this._legacyCanvasSize = canvasSizeOrOnDecodeError;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._onDecodeError = canvasSizeOrOnDecodeError;\n        }\n\n        if (typeof canvasSizeOrCalculateScanRegion === 'number') {\n            // legacy function signature where the fourth argument is the canvas size\n            this._legacyCanvasSize = canvasSizeOrCalculateScanRegion;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._calculateScanRegion = canvasSizeOrCalculateScanRegion;\n        }\n\n        this._scanRegion = this._calculateScanRegion(video);\n\n        this._onPlay = this._onPlay.bind(this);\n        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\n        video.disablePictureInPicture = true;\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        video.muted = true;\n\n        // Avoid Safari stopping the video stream on a hidden video.\n        // See https://github.com/cozmo/jsQR/issues/185\n        let shouldHideVideo = false;\n        if (video.hidden) {\n            video.hidden = false;\n            shouldHideVideo = true;\n        }\n        if (!document.body.contains(video)) {\n            document.body.appendChild(video);\n            shouldHideVideo = true;\n        }\n        requestAnimationFrame(() => {\n            // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.\n            const computedStyle = window.getComputedStyle(video);\n            if (computedStyle.display === 'none') {\n                video.style.setProperty('display', 'block', 'important');\n                shouldHideVideo = true;\n            }\n            if (computedStyle.visibility !== 'visible') {\n                video.style.setProperty('visibility', 'visible', 'important');\n                shouldHideVideo = true;\n            }\n            if (shouldHideVideo) {\n                // Hide the video in a way that doesn't cause Safari to stop the playback.\n                console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');\n                video.style.opacity = 0;\n                video.style.width = 0;\n                video.style.height = 0;\n            }\n        });\n\n        video.addEventListener('play', this._onPlay);\n        video.addEventListener('loadedmetadata', this._onLoadedMetaData);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n\n        this._qrEnginePromise = QrScanner.createQrEngine();\n    }\n\n    /* async */\n    hasFlash() {\n        let openedStream = null;\n        return (this.$video.srcObject\n            ? Promise.resolve(this.$video.srcObject.getVideoTracks()[0])\n            : this._getCameraStream().then(({ stream }) => {\n                console.warn('Call hasFlash after successfully starting the scanner to avoid creating '\n                    + 'a temporary video stream');\n                openedStream = stream;\n                return stream.getVideoTracks()[0];\n            })\n        )\n            .then((track) => 'torch' in track.getSettings())\n            .catch(() => false)\n            .finally(() => {\n                // close the stream we just opened for detecting whether it supports flash\n                if (!openedStream) return;\n                for (const track of openedStream.getTracks()) {\n                    track.stop();\n                    openedStream.removeTrack(track);\n                }\n            });\n    }\n\n    isFlashOn() {\n      return this._flashOn;\n    }\n\n    /* async */\n    toggleFlash() {\n        if (this._flashOn) {\n            return this.turnFlashOff();\n        } else {\n            return this.turnFlashOn();\n        }\n    }\n\n    /* async */\n    turnFlashOn() {\n        if (this._flashOn) return Promise.resolve();\n        this._flashOn = true;\n        if (!this._active || this._paused) return Promise.resolve(); // flash will be turned on later on .start()\n        return this.hasFlash().then((hasFlash) => {\n            if (!hasFlash) return Promise.reject('No flash available');\n            // Note that the video track is guaranteed to exist at this point\n            return this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n                advanced: [{ torch: true }],\n            });\n        }).catch(() => {\n            this._flashOn = false;\n            throw e;\n        });\n    }\n\n    /* async */\n    turnFlashOff() {\n        if (!this._flashOn) return;\n        // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays\n        // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,\n        // we have to stop the stream to turn the flashlight off.\n        this._flashOn = false;\n        return this._restartVideoStream();\n    }\n\n    destroy() {\n        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n\n        this.stop();\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n    }\n\n    /* async */\n    start() {\n        if (this._active && !this._paused) {\n            return Promise.resolve();\n        }\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n        this._active = true;\n        if (document.hidden) {\n            // camera will be started as soon as tab is in foreground\n            return Promise.resolve();\n        }\n        this._paused = false;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            this.$video.play();\n            return Promise.resolve();\n        }\n\n        return this._getCameraStream()\n            .then(({ stream, facingMode }) => {\n                this.$video.srcObject = stream;\n                this.$video.play();\n                this._setVideoMirror(facingMode);\n\n                // Restart the flash if it was previously on\n                if (this._flashOn) {\n                    this._flashOn = false; // force turnFlashOn to restart the flash\n                    this.turnFlashOn().catch(() => {});\n                }\n            })\n            .catch(e => {\n                this._active = false;\n                throw e;\n            });\n    }\n\n    stop() {\n        this.pause();\n        this._active = false;\n    }\n\n    /* async */\n    pause(stopStreamImmediately = false) {\n        this._paused = true;\n        if (!this._active) {\n            return Promise.resolve(true);\n        }\n        this.$video.pause();\n\n        const stopStream = () => {\n            const tracks = this.$video.srcObject ? this.$video.srcObject.getTracks() : [];\n            for (const track of tracks) {\n                track.stop(); //  note that this will also automatically turn the flashlight off\n                this.$video.srcObject.removeTrack(track);\n            }\n            this.$video.srcObject = null;\n        };\n\n        if (stopStreamImmediately) {\n            stopStream();\n            return Promise.resolve(true);\n        }\n\n        return new Promise((resolve) => setTimeout(resolve, 300))\n            .then(() => {\n                if (!this._paused) return false;\n                stopStream();\n                return true;\n            });\n    }\n\n    /* async */\n    setCamera(facingModeOrDeviceId) {\n        if (facingModeOrDeviceId === this._preferredCamera) return Promise.resolve();\n        this._preferredCamera = facingModeOrDeviceId;\n        // Restart the scanner with the new camera which will also update the video mirror and the scan region.\n        return this._restartVideoStream();\n    }\n\n    /* async */\n    static scanImage(imageOrFileOrUrl, scanRegion=null, qrEngine=null, canvas=null, disallowCanvasResizing=false,\n                     alsoTryWithoutScanRegion=false) {\n        const gotExternalWorker = qrEngine instanceof Worker;\n\n        let promise = Promise.all([\n            qrEngine || QrScanner.createQrEngine(),\n            QrScanner._loadImage(imageOrFileOrUrl),\n        ]).then(([engine, image]) => {\n            qrEngine = engine;\n            let canvasContext;\n            [canvas, canvasContext] = this._drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing);\n\n            if (qrEngine instanceof Worker) {\n                if (!gotExternalWorker) {\n                    // Enable scanning of inverted color qr codes. Not using _postWorkerMessage as it's async\n                    qrEngine.postMessage({ type: 'inversionMode', data: 'both' });\n                }\n                return new Promise((resolve, reject) => {\n                    let timeout, onMessage, onError;\n                    onMessage = event => {\n                        if (event.data.type !== 'qrResult') {\n                            return;\n                        }\n                        qrEngine.removeEventListener('message', onMessage);\n                        qrEngine.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        if (event.data.data !== null) {\n                            resolve(event.data.data);\n                        } else {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        }\n                    };\n                    onError = (e) => {\n                        qrEngine.removeEventListener('message', onMessage);\n                        qrEngine.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        const errorMessage = !e ? 'Unknown Error' : (e.message || e);\n                        reject('Scanner error: ' + errorMessage);\n                    };\n                    qrEngine.addEventListener('message', onMessage);\n                    qrEngine.addEventListener('error', onError);\n                    timeout = setTimeout(() => onError('timeout'), 10000);\n                    const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);\n                    qrEngine.postMessage({\n                        type: 'decode',\n                        data: imageData\n                    }, [imageData.data.buffer]);\n                });\n            } else {\n                return new Promise((resolve, reject) => {\n                    const timeout = setTimeout(() => reject('Scanner error: timeout'), 10000);\n                    qrEngine.detect(canvas).then(scanResults => {\n                        if (!scanResults.length) {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        } else {\n                            resolve(scanResults[0].rawValue);\n                        }\n                    }).catch((e) => reject('Scanner error: ' + (e.message || e))).finally(() => clearTimeout(timeout));\n                });\n            }\n        });\n\n        if (scanRegion && alsoTryWithoutScanRegion) {\n            promise = promise.catch(() =>\n                QrScanner.scanImage(imageOrFileOrUrl, null, qrEngine, canvas, disallowCanvasResizing));\n        }\n\n        promise = promise.finally(() => {\n            if (gotExternalWorker) return;\n            QrScanner._postWorkerMessage(qrEngine, 'close');\n        });\n\n        return promise;\n    }\n\n    setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations work also\n        // well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEnginePromise,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode) {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations scan normal\n        // and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n    }\n\n    /* async */\n    static createQrEngine(workerPath = QrScanner.WORKER_PATH) {\n        return ('BarcodeDetector' in window && BarcodeDetector.getSupportedFormats\n            ? BarcodeDetector.getSupportedFormats()\n            : Promise.resolve([])\n        )\n            .then((supportedFormats) => supportedFormats.indexOf('qr_code') !== -1\n                ? new BarcodeDetector({ formats: ['qr_code'] })\n                : new Worker(workerPath)\n            );\n    }\n\n    _onPlay() {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._scanFrame();\n    }\n\n    _onLoadedMetaData() {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n    }\n\n    _onVisibilityChange() {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    _calculateScanRegion(video) {\n        // Default scan region calculation. Note that this can be overwritten in the constructor.\n        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\n        const scanRegionSize = Math.round(2 / 3 * smallestDimension);\n        return {\n            x: Math.round((video.videoWidth - scanRegionSize) / 2),\n            y: Math.round((video.videoHeight - scanRegionSize) / 2),\n            width: scanRegionSize,\n            height: scanRegionSize,\n            downScaledWidth: this._legacyCanvasSize,\n            downScaledHeight: this._legacyCanvasSize,\n        };\n    }\n\n    _scanFrame() {\n        if (!this._active || this.$video.paused || this.$video.ended) return false;\n        // using requestAnimationFrame to avoid scanning if tab is in background\n        requestAnimationFrame(() => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n            this._qrEnginePromise\n                .then((qrEngine) => QrScanner.scanImage(this.$video, this._scanRegion, qrEngine, this.$canvas))\n                .then(this._onDecode, (error) => {\n                    if (!this._active) return;\n                    const errorMessage = error.message || error;\n                    if (errorMessage.indexOf('service unavailable') !== -1) {\n                        // When the native BarcodeDetector crashed, create a new one\n                        this._qrEnginePromise = QrScanner.createQrEngine();\n                    }\n                    this._onDecodeError(error);\n                })\n                .then(() => this._scanFrame());\n        });\n    }\n\n    _onDecodeError(error) {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    /* async */\n    _getCameraStream() {\n        if (!navigator.mediaDevices) {\n            return Promise.reject('Camera not found.');\n        }\n\n        const preferenceType = this._preferredCamera === 'environment' || this._preferredCamera === 'user'\n            ? 'facingMode'\n            : 'deviceId';\n        const constraintsWithoutCamera = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n        const constraintsWithCamera = constraintsWithoutCamera.map((constraint) => Object.assign({}, constraint, {\n            [preferenceType]: { exact: this._preferredCamera },\n        }));\n\n        // First try constraints with camera, then without camera. Using reduceRight as the Promise is build in a\n        // bottom up fashion.\n        return [...constraintsWithCamera, ...constraintsWithoutCamera].reduceRight((fallback, constraint) =>\n            () => navigator.mediaDevices.getUserMedia({ video: constraint, audio: false })\n                .then((stream) => ({\n                    stream,\n                    // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as\n                    // default. Note that the guess is not always accurate as Safari returns cameras of different facing\n                    // mode, even for exact facingMode constraints.\n                    facingMode: this._getFacingMode(stream)\n                        || (constraint.facingMode\n                            ? this._preferredCamera // _preferredCamera is a facing mode and we are able to fulfill it\n                            : (this._preferredCamera === 'environment'\n                                ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it\n                                : 'environment' // switch from unfulfilled user facingMode or default to environment\n                            )\n                        ),\n                }))\n                .catch(fallback),\n            () => Promise.reject('Camera not found.')\n        )();\n    }\n\n    /* async */\n    _restartVideoStream() {\n        // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the\n        // stream might still be running, as it's by default only stopped after a delay of 300ms.\n        const wasPaused = this._paused;\n        return this.pause(true).then((paused) => {\n            if (!paused || wasPaused || !this._active) return;\n            return this.start();\n        });\n    }\n\n    _setVideoMirror(facingMode) {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode==='user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    _getFacingMode(videoStream) {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    static _drawToCanvas(image, scanRegion=null, canvas=null, disallowCanvasResizing=false) {\n        canvas = canvas || document.createElement('canvas');\n        const scanRegionX = scanRegion && scanRegion.x? scanRegion.x : 0;\n        const scanRegionY = scanRegion && scanRegion.y? scanRegion.y : 0;\n        const scanRegionWidth = scanRegion && scanRegion.width? scanRegion.width : image.width || image.videoWidth;\n        const scanRegionHeight = scanRegion && scanRegion.height? scanRegion.height : image.height || image.videoHeight;\n\n        if (!disallowCanvasResizing) {\n            const canvasWidth = scanRegion && scanRegion.downScaledWidth\n                ? scanRegion.downScaledWidth\n                : scanRegionWidth;\n            const canvasHeight = scanRegion && scanRegion.downScaledHeight\n                ? scanRegion.downScaledHeight\n                : scanRegionHeight;\n            // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only\n            // set them if they actually changed.\n            if (canvas.width !== canvasWidth) {\n                canvas.width = canvasWidth;\n            }\n            if (canvas.height !== canvasHeight) {\n                canvas.height = canvasHeight;\n            }\n        }\n\n        const context = canvas.getContext('2d', { alpha: false });\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(\n            image,\n            scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight,\n            0, 0, canvas.width, canvas.height\n        );\n        return [canvas, context];\n    }\n\n    /* async */\n    static _loadImage(imageOrFileOrBlobOrUrl) {\n        if (imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement || imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || window.ImageBitmap && imageOrFileOrBlobOrUrl instanceof window.ImageBitmap\n            || window.OffscreenCanvas && imageOrFileOrBlobOrUrl instanceof window.OffscreenCanvas) {\n            return Promise.resolve(imageOrFileOrBlobOrUrl);\n        } else if (imageOrFileOrBlobOrUrl instanceof Image) {\n            return QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl).then(() => imageOrFileOrBlobOrUrl);\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof(imageOrFileOrBlobOrUrl)==='string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl;\n            }\n            return QrScanner._awaitImageLoad(image).then(() => {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n                return image;\n            });\n        } else {\n            return Promise.reject('Unsupported image type.');\n        }\n    }\n\n    /* async */\n    static _awaitImageLoad(image) {\n        return new Promise((resolve, reject) => {\n            if (image.complete && image.naturalWidth!==0) {\n                // already loaded\n                resolve();\n            } else {\n                let onLoad, onError;\n                onLoad = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    resolve();\n                };\n                onError = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    reject('Image load error');\n                };\n                image.addEventListener('load', onLoad);\n                image.addEventListener('error', onError);\n            }\n        });\n    }\n\n    /* async */\n    static _postWorkerMessage(qrEngineOrQrEnginePromise, type, data) {\n        return Promise.resolve(qrEngineOrQrEnginePromise).then((qrEngine) => {\n            if (!(qrEngine instanceof Worker)) return;\n            qrEngine.postMessage({ type, data });\n        });\n    }\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400;\nQrScanner.NO_QR_CODE_FOUND = 'No QR code found';\nQrScanner.WORKER_PATH = 'qr-scanner-worker.min.js';\n"],"names":["QrScanner","listCameras","then","cameras","length","catch","requestLabels","navigator","mediaDevices","Promise","resolve","openedStream","getUserMedia","audio","video","stream","enumerateDevices","devices","filter","device","kind","map","i","id","deviceId","label","finally","track","stop","removeTrack","onDecode","canvasSizeOrOnDecodeError","_onDecodeError","canvasSizeOrCalculateScanRegion","_calculateScanRegion","preferredCamera","$video","$canvas","document","createElement","_onDecode","_legacyCanvasSize","DEFAULT_CANVAS_SIZE","_preferredCamera","_flashOn","_paused","_active","console","warn","_scanRegion","_onPlay","bind","_onLoadedMetaData","_onVisibilityChange","disablePictureInPicture","playsInline","muted","shouldHideVideo","hidden","body","contains","appendChild","requestAnimationFrame","computedStyle","display","style","setProperty","visibility","opacity","width","height","addEventListener","_qrEnginePromise","createQrEngine","srcObject","getVideoTracks","_getCameraStream","getSettings","turnFlashOff","turnFlashOn","hasFlash","applyConstraints","advanced","torch","reject","e","_restartVideoStream","removeEventListener","_postWorkerMessage","window","location","protocol","play","facingMode","_setVideoMirror","pause","stopStreamImmediately","tracks","getTracks","stopStream","setTimeout","facingModeOrDeviceId","imageOrFileOrUrl","scanRegion","qrEngine","canvas","disallowCanvasResizing","alsoTryWithoutScanRegion","promise","all","_loadImage","engine","image","canvasContext","_drawToCanvas","Worker","gotExternalWorker","postMessage","type","data","timeout","onMessage","onError","event","clearTimeout","NO_QR_CODE_FOUND","imageData","buffer","detect","scanResults","rawValue","message","scanImage","red","green","blue","useIntegerApproximation","inversionMode","workerPath","WORKER_PATH","BarcodeDetector","getSupportedFormats","supportedFormats","indexOf","formats","_scanFrame","start","videoHeight","x","Math","round","videoWidth","scanRegionSize","y","downScaledWidth","downScaledHeight","paused","ended","readyState","error","log","min","constraint","preferenceType","exact","constraintsWithoutCamera","reduceRight","fallback","_getFacingMode","wasPaused","transform","videoStream","test","videoTrack","scanRegionWidth","scanRegionHeight","canvasWidth","canvasHeight","alpha","context","imageSmoothingEnabled","drawImage","scanRegionX","scanRegionY","imageOrFileOrBlobOrUrl","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","OffscreenCanvas","Image","_awaitImageLoad","File","Blob","URL","src","createObjectURL","revokeObjectURL","complete","naturalWidth","onLoad","qrEngineOrQrEnginePromise"],"mappings":"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"}